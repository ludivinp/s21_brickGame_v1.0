# BrickGame «Тетрис»
Учебный проект школы 21.  
В данном проекте я реализовал игру «Тетрис» на языке программирования 'C' с использованием структурного подхода.

## Общая информация
### BrickGame?
BrickGame — популярная портативная консоль 90-ых годов с несколькими ~~тысячами~~ встроенными играми, разработанная в Китае. Изначально была копией разработанной в СССР и выпущенной Nintendo в рамках платформы GameBoy игры «Тетрис», но включала в себя также и множество других игр, которые добавлялись с течением времени. Консоль имела небольшой экранчик с игровым полем размера 10х20, представляющим из себя матрицу «пикселей». Справа от поля находилось табло с цифровой индикацией состояния текущей игры, рекордами и прочей дополнительной информацией. Самыми распространенными играми на BrickGame были: тетрис, танки, гонки, фроггер и змейка.

##
Это задание является первым из серии BrickGame. Всего будет четыре проекта, в каждой - своя игра и свои технологии. Но помимо разработки новых проектов, необходимо будет поддерживать и старые игры, и добавлять поддержку новых игр в старые проекты. В этот раз интерфейс будет консольным, в следующем - десктопный, и так далее. Для того чтобы поддерживать старые и новые игры необходимо заранее определиться как будет устроено АПИ интерфейсов и библиотек, чтобы в дальнейшем не приходилось переписывать уже сданные проекты.

Проект состоит из двух частей: библиотеки, реализующая логику работы игры и терминального интерфейса, разработанного с использованием библиотеки ncurses. Логика работы библиотеки реализована с использованием конечных автоматов.  
## Требования к проекту по заданию

### Основные требования
- Программа должна быть разработана на языке Си стандарта C11 с использованием компилятора gcc.
- Программа должна состоять из двух частей: библиотеки, реализующей логику игры тетрис, и терминального интерфейса с использованием библиотеки `ncurses`.
- Для формализации логики игры должен быть использован конечный автомат.
- Библиотека должна иметь функцию, принимающая на вход ввод пользователя, и функцию, выдающую матрицу, которая описывает текущее состояние игрового поля, при каждом ее изменении.
- Код библиотеки программы должен находиться в папке `src/brick_game/tetris`.
- Код с интерфейсом программы должен находиться в папке `src/gui/cli`.
- Сборка программы должна быть настроена с помощью Makefile со стандартным набором целей для GNU-программ: all, install, uninstall, clean, dvi, dist, test, gcov_report. Установка должна вестись в любой другой произвольный каталог.
- Программа должна быть разработана в соответствии с принципами структурного программирования.
- При написании кода придерживайся Google Style.
- Должно быть обеспечено покрытие библиотеки unit-тестами, с помощью библиотеки `check` (тесты должны проходить на ОС Darwin/Ubuntu). Покрытие библиотеки с логикой игры тестами должно составлять не меньше 80 процентов.
- В игре должны присутствовать следующие механики:
  - Вращение фигур;
  - Перемещение фигуры по горизонтали;
  - Ускорение падения фигуры (при нажатии кнопки фигура перемещается до конца вниз);
  - Показ следующей фигуры;
  - Уничтожение заполненных линий;
  - Завершение игры при достижении верхней границы игрового поля;
  - В игре должны присутствовать все виды фигур, показанных на картинке ниже.
- Для управления добавь поддержку всех кнопок, предусмотренных на физической консоли:
  - Начало игры,
  - Пауза,
  - Завершение игры,
  - Стрелка влево — движение фигуры влево,
  - Стрелка вправо — движение фигуры вправо,
  - Стрелка вниз — падение фигуры,
  - Стрелка вверх — ни используется в данной игре,
  - Действие (вращение фигуры).
- Игровое поле должно соответствовать размерам игрового поля консоли — десять «пикселей» в ширину и двадцать «пикселей» в высоту.
- Фигура, после достижения нижней границы поля или соприкосновения с другой фигурой, должна остановиться. После этого происходит генерация следующей фигуры, показанной на превью.
- Интерфейс библиотеки должен соответствовать описанию, которое находится в materials/library-specification.md.
- Пользовательский интерфейс должен поддерживать отрисовку игрового поля и дополнительной информации.
- Подготовь в любом формате диаграмму, описывающую используемый КА (его состояния и все возможные переходы).



### Дополнительные требования
- Подсчет очков. Начисление очков будет происходить следующим образом:
  - 1 линия — 100 очков;
  - 2 линии — 300 очков;
  - 3 линии — 700 очков;
  - 4 линии — 1500 очков.
- Хранение максимального количества очков. Максимальное количество очков должно изменяться во время игры, если пользователь во время игры превышает текущий показатель максимального количества набранных очков.

- Механика уровней. Каждый раз, когда игрок набирает 600 очков, уровень увеличивается на 1.
- Повышение уровня увеличивает скорость движения фигур. Максимальное количество уровней — 10.

Необходимые фигуры:

![Фигуры](misc/images/tetris-pieces.png)

## Спецификация для всех игровых библиотек
- Игровое поле представляется как матрица размерностью десять на двадцать.
- Каждый элемент матрицы соответствует "пикселю" игрового поля и может находится в одном из двух состояний: пустой и заполненный.
- Кроме игрового поля у каждой игры есть дополнительная информация, которая выводится в боковой панели справа от игрового поля.
- Для дополнительной информации, не используемой во время игры, предусмотреть заглушки.
- Каждая библиотека с игрой должна иметь функцию, принимающую на вход пользовательский ввод.
- У консоли имеется восемь физических кнопок: начало игры, пауза, завершение игры, действие и четыре стрелочки.

### Интерфейсы
- Функция `userInput` принимает на вход пользовательское действие `action` и дополнительный параметр `hold`, который отвечает за зажатие клавиши.
  ```c
  typedef enum {
    Start,
    Pause,
    Terminate,
    Left,
    Right,
    Up,
    Down,
    Action
  } UserAction_t;
  
  void userInput(UserAction_t action, bool hold);
  ```
- Функция `updateCurrentState` предназначена для получения данных для отрисовки в интерфейсе. Она возвращает структуру, содержащую информацию о текущем состоянии игры. Например, для тетриса истечение таймера приводит к смещению фигуры вниз на один ряд. Эта функция должна вызываться из интерфейса с некоторой периодичностью для поддержания интерфейса в актуальном состоянии.
  ```c
  typedef struct {
    int **field;
    int **next;
    int score;
    int high_score;
    int level;
    int speed;
    int pause;
  } GameInfo_t;
  
  GameInfo_t updateCurrentState();
  ```

## Диаграмма КА
<img src="misc/diagram.png" width="300">

# Итоговый результат
![Фигуры](misc/logo.png)


